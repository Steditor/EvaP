\usetikzlibrary{arrows,automata}

\subsubsection{Selected Control Flow Graph}
We chose to test the function \texttt{send\_publish\_notifications} from \texttt{evaluation/tools.py}.
As most of EvaP's functionality deals with data management, this is one of the few functions with a complex control flow graph.
Its purpose is to send an email notification to participants and contributers of all courses for which new evaluation results have been published.
To achieve this, the function has to traverse all newly published resources, collect the involved users and merge the notifications per user in order to send each user at most one mail.

During our research we found two promising tools for automatic control flow graph creation. 
The first tool is open source and hosted on GitHub (\url{https://github.com/danielrandall/python-control-flow-graph}). 
Unfortunately, it is not documented and its execution lead to errors. 
After a few tries, we estimated that fixing the tool would take more time than creating the control flow graph by hand.
The second tool found was even more promising as it was a report of a master graduate from the university of Texas titled: 
``Control flow graph visualisation and its application to coverage and fault localization in Python''
by Jackson Lee Salling.
His tool even visualized edge-pair and prime path coverage in control flow graphs.
But unfortunately he did not respond to our request if we could use the tool for our project or if he had tips for published tools.
Therefore, we created the control flow graph by hand.

We experienced some difficulties with Python's code style, for example with the assignment of default values to missing parameters:
\begin{lstlisting}[language=Python, breaklines]
def send_publish_notifications(grade_document_courses=None, evaluation_results_courses=None):
    grade_document_courses = grade_document_courses or []
\end{lstlisting}
This assignment of either the \texttt{grade\_document\_courses} or an empty list is dependent on the evaluation of \texttt{grade\_document\_courses}.
Here are several statements hidden in one line, disguised by a lazy evaluation of a boolean disjunction.

\lstinputlisting[language=Python, breaklines, columns=flexible, float, label=lst:send_publish_notifications, caption=The control flow graph is based on this function.]{code/send_publish_notifications.py}

\input{tikz_control_flow_graph}
\begin{figure}
\resizebox{\linewidth}{!}{	
	\begin{tikzpicture}[node distance=2cm, dummy/.style={circle,fill=blue!20,draw}]
	\pic {sendPublishNotifications={}};
	\end{tikzpicture}
}
\caption{Control Flow Graph of the Function \texttt{send\_publish\_notifications} in \url{evap/evaluation/tools.py}}
\end{figure}

As the chosen function takes two lists of courses with published results as input values, one can almost achieve Node and Edge Coverage with only one test case, that includes one course for each if/else-branch.
Only the assignment of empty lists as default arguments would require a second test case.
This clearly shows, that neither Node nor Edge Coverage alone is an appropriate coverage criteria to decide whether the function has been fully tested, as both test cases are highly unrealistic.
Additionally, the complexity of the first test case would be comparable to the complexity of the tested function itself, which makes it just as likely that the test case contains faults as that failing tests flag a fault in the tested code.

Edge Pair Coverage seems to be a much more useful criteria in this case, as it is able to describe whether loops have been executed or bypassed.
For example, one would have to implement both a test case which enters the loop in node $7_{for}$ via the edge pair $(5,7_{for}), (7_{for},9_{if})$ and to bypass it using the edges $(5,7_{for}), (7_{for},21_{for})$.
Edge Pair Coverage would also require a test set that executes the edge pair $(21_{for}, 23_{for}), (23_{for}, 21_{for})$ --- a path that would only be executed if the function processes a course without participants.
This however is an impossible input, and even though the test case could still simulate this kind of input, it does not make much sense to test a setting that can not occur, as a course with results always needs to have at least one participant.

Requesting the test set to achieve Complete Path Coverage is also not possible, as the function under test contains multiple loops.
Therefore, Prime Path Coverage would be a possible criteria to test the function with each loop being bypassed, run once and run twice.
However, the graph coverage tool provided by Ammann and Offutt%
\footnote{\url{https://cs.gmu.edu:8443/offutt/coverage/GraphCoverage}}
determines a total of 101 necessary test paths to cover all prime paths.
Even if we would remove all infeasible test paths from that list, the number of test paths would still be over-the-top.

Hence, we decided to go for Specified Path Coverage to cover typical usages of the function and also some special cases that could lead to unexpected behavior.
This lead to a test set of six test cases, that achieve both Node and Edge Coverage. (\autoref{fig:cfg-test-cases})
The first test case runs the function without arguments, hence testing the usage of the default arguments.
Test cases two and three test, whether a course with results notifies its participants and contributers, whereas the fourth test case asserts, that a course without results won't do so.
In the fifth and sixth test cases the functions behavior with uploaded grade documents is checked.

\begin{figure}[htb]
	\resizebox{0.3\linewidth}{!}{	
		\begin{tikzpicture}[node distance=2cm, dummy/.style={circle,fill=blue!20,draw}]
		\pic {sendPublishNotifications={}};
		
		\path[draw=green, opacity=0.6, line width=4mm]
		(l1) -- (l2a) -- (l2b) -- (l2) -- (l3a) -- (l3b) -- (l3) -- (l5) -- (l7) -- (l21) -- (l27) -- (l33);
		\end{tikzpicture}
	}
	\resizebox{0.3\linewidth}{!}{	
		\begin{tikzpicture}[node distance=2cm, dummy/.style={circle,fill=blue!20,draw}]
		\pic {sendPublishNotifications={}};
		
		\path[draw=green, opacity=0.6, line width=4mm]
		(l1) -- (l2a) -- (l2b) -- (l2) -- (l3a) -- (l3) -- (l5) -- (l7) edge [bend right=15] (l9) 
		(l9) -- (l10) edge [bend right] (l11)
		(l11) edge [bend right] (l10)
		(l10) -- (l12) -- (l13) -- (l13-e) edge [bend left] (l12)
		(l12) -- (l13) -- (l14) edge [bend right=75] (l12)
		(l12) edge [bend left=45] (l7)
		(l7) -- (l21) -- (l27) -- (l28) edge [bend left] (l27)
		(l27) -- (l33);
		\end{tikzpicture}
	}
	\resizebox{0.3\linewidth}{!}{	
		\begin{tikzpicture}[node distance=2cm, dummy/.style={circle,fill=blue!20,draw}]
		\pic {sendPublishNotifications={}};
		
		\path[draw=green, opacity=0.6, line width=4mm]
		(l1) -- (l2a) -- (l2b) -- (l2) -- (l3a) -- (l3) -- (l5) -- (l7) edge [bend right=15] (l9) 
		(l9) -- (l16) -- (l17) -- (l18) -- (l18-e) edge [bend left] (l17)
		(l17) -- (l18) -- (l19) edge [bend right=75] (l17)
		(l17) edge [bend left] (l20)
		(l20) -- (l7)
		(l7) -- (l21) -- (l27) -- (l28) edge [bend left] (l27)
		(l27) -- (l33);
		\end{tikzpicture}
	}
	\resizebox{0.3\linewidth}{!}{	
		\begin{tikzpicture}[node distance=2cm, dummy/.style={circle,fill=blue!20,draw}]
		\pic {sendPublishNotifications={}};
		
		\path[draw=green, opacity=0.6, line width=4mm]
		(l1) -- (l2a) -- (l2b) -- (l2) -- (l3a) -- (l3) -- (l5) -- (l7) edge [bend right=15] (l9) 
		(l9) -- (l16) -- (l9-16-e) -- (l7)
		(l7) -- (l21) -- (l27) -- (l28) edge [bend left] (l27)
		(l27) -- (l33);
		\end{tikzpicture}
	}
	\resizebox{0.3\linewidth}{!}{	
		\begin{tikzpicture}[node distance=2cm, dummy/.style={circle,fill=blue!20,draw}]
		\pic {sendPublishNotifications={}};
		
		\path[draw=green, opacity=0.6, line width=4mm]
		(l1) -- (l2a) -- (l2b) -- (l2) -- (l3a) -- (l3) -- (l5) -- (l7) -- (l21) -- (l23) -- (l24) -- (l25) edge [bend right=75] (l23)
		(l23) edge [bend left] (l21)
		(l21) -- (l27) -- (l28) edge [bend left] (l27)
		(l27) -- (l33);
		\end{tikzpicture}
	}
	\resizebox{0.3\linewidth}{!}{	
		\begin{tikzpicture}[node distance=2cm, dummy/.style={circle,fill=blue!20,draw}]
		\pic {sendPublishNotifications={}};
		
		\path[draw=green, opacity=0.6, line width=4mm]
		(l1) -- (l2a) -- (l2b) -- (l2) -- (l3a) -- (l3) -- (l5) -- (l7) -- (l21) -- (l23) -- (l24) -- (l24-e) edge [bend left] (l23)
		(l23) edge [bend left] (l21)
		(l21) -- (l27) -- (l28) edge [bend left] (l27)
		(l27) -- (l33);
		\end{tikzpicture}
	}
	\caption{Visualization of the six test cases to cover \texttt{send\_publish\_notifications}.}
	\label{fig:cfg-test-cases}
\end{figure}

Even though the graph seemingly is covered by these test cases, in reality there still would be common usages of the function that remain uncovered by the test set.
For example, if a student is participant in two published courses, he should not receive two notifications, but be notified about both changes in one mail.
This shows, why Specified Path Coverage can easily lead to a ill-founded feeling of good testing coverage.
We will handle some of the remaining special cases in \autoref{sec:input-coverage} where we discuss \nameref{sec:input-coverage}.

Additionally one has to keep in mind, that in order to test the given function we had to mock both 3rd-Party interfaces (in our case the Django function to send emails) and the input data structures.
The frameworks used in EvaP allowed us to do this without much effort.
However, this approach includes the risk of building input data objects that are inconsistent with the structure of data that the function has to work with in production.
